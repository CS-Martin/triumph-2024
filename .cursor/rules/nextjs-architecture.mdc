---
description: Next.js architecture guidelines and patterns
globs: src/**/*.ts,src/**/*.tsx,src/**/*.js,src/**/*.jsx
alwaysApply: true
---

# Next.js Architecture Guidelines

## Overview

This project follows a feature-driven architecture with Next.js App Router, Convex backend, and modern React patterns. The codebase emphasizes separation of concerns, type safety, and maintainable component organization.

## Core Architecture Patterns

### 1. App Router Structure

- **Location**: `src/app/`
- **Pattern**: File-based routing with App Router conventions
- **Layout**: Root layout wraps all pages with providers
- **API Routes**: Server actions in `src/app/api/`

**Example**: `src/app/layout.tsx`

```typescript
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";
import { ConvexClientProvider } from "@/providers/convex-client.provider";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body className={`${geistSans.variable} ${geistMono.variable} antialiased`}>
        <ConvexClientProvider>
          {children}
        </ConvexClientProvider>
      </body>
    </html>
  );
}
```

### 2. Feature-Based Organization

- **Location**: `src/features/{feature-name}/`
- **Pattern**: Self-contained feature modules with clear boundaries
- **Structure**: Each feature contains its own services, components, types, and schemas

```
src/features/{feature}/
├── ai-agent/           # AI/ML integration logic
├── lib/                # Feature-specific utilities and constants
├── schema/             # Zod schemas and type definitions
├── services/           # Business logic and external API calls
└── types/              # TypeScript type definitions
```

**Example**: `src/features/casino-discovery/services/casino-discovery.service.ts`

```typescript
import { DiscoverCasino } from '../schema/schema';
import { ConvexHttpClient } from 'convex/browser';
import { api } from '../../../../convex/_generated/api';

const convex = new ConvexHttpClient(process.env.NEXT_PUBLIC_CONVEX_URL!);

export class CasinoDiscoveryService {
  static async saveDiscoveredCasinos(discoveredData: DiscoverCasino[]): Promise<SaveResult> {
    // Implementation logic here
  }
}
```

### 3. Component Architecture

- **Location**: `src/components/`
- **Pattern**: Reusable UI components with shadcn/ui foundation
- **Structure**: Organized by component type and complexity

```
src/components/
├── custom/             # My owncustom components
├── layout/             # Layout components
├── ui/                 # Base UI components (shadcn/ui)
│   ├── button.tsx
│   ├── table.tsx
│   └── pagination.tsx
└── {feature}/          # Feature-specific components
```

**Example**: `src/components/ui/button.tsx`

```typescript
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"
import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive: "bg-destructive text-white hover:bg-destructive/90",
        outline: "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground",
        // ... more variants
      },
      size: {
        default: "h-9 px-4 py-2",
        sm: "h-8 rounded-md gap-1.5 px-3",
        lg: "h-10 rounded-md px-6",
        // ... more sizes
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean
  }) {
  const Comp = asChild ? Slot : "button"
  return (
    <Comp
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Button, buttonVariants }
```

### 4. Provider Pattern

- **Location**: `src/providers/`
- **Pattern**: Context providers for global state and external services
- **Usage**: Wrap app in root layout

**Example**: `src/providers/convex-client.provider.tsx`

```typescript
"use client";

import { ConvexProvider, ConvexReactClient } from "convex/react";
import { ReactNode } from "react";

const convex = new ConvexReactClient(process.env.NEXT_PUBLIC_CONVEX_URL!);

export function ConvexClientProvider({ children }: { children: ReactNode }) {
  return <ConvexProvider client={convex}>{children}</ConvexProvider>;
}
```

### 5. API Route Pattern

- **Location**: `src/app/api/{route}/route.ts`
- **Pattern**: Server-side API handlers with proper error handling
- **Structure**: Named exports for HTTP methods

**Example**: `src/app/api/discover-casinos/route.ts`

```typescript
import { NextResponse } from 'next/server';
import { DiscoverCasino } from '@/features/casino-discovery/ai-agent/discover-casino';
import { CasinoDiscoveryService } from '@/features/casino-discovery/services/casino-discovery.service';

export async function POST() {
  try {
    const discovered = await DiscoverCasino();
    const result = await CasinoDiscoveryService.saveDiscoveredCasinos(discovered.discoverCasino);

    return NextResponse.json({ ok: true, result });
  } catch (error: any) {
    return NextResponse.json({ ok: false, error: error?.message ?? 'Unknown error' }, { status: 500 });
  }
}
```

## TypeScript Configuration

### Path Aliases

```json
{
  "compilerOptions": {
    "paths": {
      "@generated/*": ["./generated/*"],
      "@convex/*": ["./convex/*"],
      "@/*": ["./src/*"]
    }
  }
}
```

### Import Patterns

- **Absolute imports**: Use `@/` prefix for src files
- **Convex imports**: Use `@convex/` prefix for generated files
- **Relative imports**: Only for same-directory files

```typescript
// ✅ Good
import { Button } from '@/components/ui/button';
import { api } from '@convex/_generated/api';
import { CasinoDiscoveryService } from '@/features/casino-discovery/services/casino-discovery.service';

// ❌ Avoid
import { Button } from '../../components/ui/button';
import { api } from '../../../convex/_generated/api';
```

## Styling Guidelines

### Tailwind CSS + shadcn/ui

- **Base**: Use Tailwind CSS for styling
- **Components**: Build on shadcn/ui component library
- **Utilities**: Use `cn()` helper for conditional classes

```typescript
import { cn } from "@/lib/utils";

function MyComponent({ className, variant }: Props) {
  return (
    <div className={cn(
      "base-styles",
      variant === "primary" && "primary-styles",
      className
    )}>
      Content
    </div>
  );
}
```

### CSS Organization

- **Global styles**: `src/app/globals.css`
- **Component styles**: Inline with Tailwind classes
- **Custom CSS**: Only when Tailwind utilities insufficient

## State Management

### Convex Integration

- **Client state**: Use Convex React hooks
- **Server state**: Managed by Convex backend
- **Local state**: React useState for component-level state

```typescript
"use client";

import { useQuery } from "convex/react";
import { api } from "@convex/_generated/api";

function CasinosList() {
  const casinos = useQuery(api.casinos.index.getAllCasinos);
  const [isDiscovering, setIsDiscovering] = useState(false);

  if (casinos === undefined) return <div>Loading casinos…</div>;
  if (!casinos?.length) return <div>No casinos found.</div>;

  return (
    // Component JSX
  );
}
```

### Loading States with Skeletons

- **Pattern**: Use shadcn/ui Skeleton component for all data-fetching components
- **Location**: Import from `@/components/ui/skeleton`
- **Usage**: Replace loading text with skeleton placeholders that match the final layout

**Example**: Dashboard KPI Cards with skeleton loading

```typescript
"use client";

import { useQuery } from "convex/react";
import { api } from "@convex/_generated/api";
import { Skeleton } from "@/components/ui/skeleton";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";

function KPICard({ title, value, isLoading }: { title: string; value: string; isLoading: boolean }) {
  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
        <CardTitle className="text-sm font-medium">{title}</CardTitle>
      </CardHeader>
      <CardContent>
        {isLoading ? (
          <Skeleton className="h-8 w-24" />
        ) : (
          <div className="text-2xl font-bold">{value}</div>
        )}
      </CardContent>
    </Card>
  );
}

function DashboardKPIs() {
  const casinoStats = useQuery(api.casinos.index.getCasinoStats);
  const isLoading = casinoStats === undefined;

  return (
    <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-4">
      <KPICard
        title="Total Casinos"
        value={casinoStats?.total.toString() || "0"}
        isLoading={isLoading}
      />
      <KPICard
        title="Tracked Casinos"
        value={casinoStats?.tracked.toString() || "0"}
        isLoading={isLoading}
      />
      <KPICard
        title="Untracked Casinos"
        value={casinoStats?.untracked.toString() || "0"}
        isLoading={isLoading}
      />
      <KPICard
        title="States Covered"
        value={casinoStats?.states.toString() || "0"}
        isLoading={isLoading}
      />
    </div>
  );
}
```

**Example**: Table with skeleton rows

```typescript
"use client";

import { useQuery } from "convex/react";
import { api } from "@convex/_generated/api";
import { Skeleton } from "@/components/ui/skeleton";
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table";

function CasinosTable() {
  const casinos = useQuery(api.casinos.index.getAllCasinos);
  const isLoading = casinos === undefined;

  if (isLoading) {
    return (
      <Table>
        <TableHeader>
          <TableRow>
            <TableHead>Name</TableHead>
            <TableHead>Website</TableHead>
            <TableHead>License</TableHead>
            <TableHead>State</TableHead>
            <TableHead className="text-right">Tracked</TableHead>
          </TableRow>
        </TableHeader>
        <TableBody>
          {Array.from({ length: 5 }).map((_, i) => (
            <TableRow key={i}>
              <TableCell><Skeleton className="h-4 w-32" /></TableCell>
              <TableCell><Skeleton className="h-4 w-24" /></TableCell>
              <TableCell><Skeleton className="h-4 w-20" /></TableCell>
              <TableCell><Skeleton className="h-4 w-16" /></TableCell>
              <TableCell className="text-right"><Skeleton className="h-4 w-12" /></TableCell>
            </TableRow>
          ))}
        </TableBody>
      </Table>
    );
  }

  if (!casinos?.length) return <div>No casinos found.</div>;

  return (
    <Table>
      <TableHeader>
        <TableRow>
          <TableHead>Name</TableHead>
          <TableHead>Website</TableHead>
          <TableHead>License</TableHead>
          <TableHead>State</TableHead>
          <TableHead className="text-right">Tracked</TableHead>
        </TableRow>
      </TableHeader>
      <TableBody>
        {casinos.map((casino) => (
          <TableRow key={casino._id}>
            <TableCell>{casino.name}</TableCell>
            <TableCell>{casino.website || "—"}</TableCell>
            <TableCell>{casino.license_status || "—"}</TableCell>
            <TableCell>{casino.state?.abbreviation || "—"}</TableCell>
            <TableCell className="text-right">{casino.is_tracked ? "Yes" : "No"}</TableCell>
          </TableRow>
        ))}
      </TableBody>
    </Table>
  );
}
```

**Skeleton Component Guidelines**:

- **Match dimensions**: Skeleton width/height should approximate final content
- **Consistent spacing**: Use same padding/margins as loaded content
- **Multiple skeletons**: Show 3-5 skeleton items for lists/tables
- **Realistic shapes**: Use appropriate skeleton shapes (rectangles for text, circles for avatars)
- **Accessibility**: Skeletons provide visual feedback during loading states

## Error Handling Patterns

### API Routes

```typescript
export async function POST() {
  try {
    // Business logic
    return NextResponse.json({ ok: true, result });
  } catch (error: any) {
    return NextResponse.json(
      {
        ok: false,
        error: error?.message ?? 'Unknown error',
      },
      { status: 500 }
    );
  }
}
```

### Client Components

```typescript
async function handleAction() {
  try {
    setIsLoading(true);
    const res = await fetch('/api/endpoint', { method: 'POST' });
    if (!res.ok) throw new Error('Action failed');
  } catch (err) {
    console.error(err);
    // Handle error state
  } finally {
    setIsLoading(false);
  }
}
```

## File Naming Conventions

### Components

- **Files**: PascalCase (`Button.tsx`, `CasinoList.tsx`)
- **Directories**: kebab-case (`casino-discovery/`, `ui/`)

### Services and Utilities

- **Files**: kebab-case (`casino-discovery.service.ts`, `utils.ts`)
- **Classes**: PascalCase (`CasinoDiscoveryService`)
- **Functions**: camelCase (`saveDiscoveredCasinos`)

### Types and Schemas

- **Files**: kebab-case (`schema.ts`, `types.ts`)
- **Types**: PascalCase (`DiscoverCasino`, `SaveResult`)
- **Interfaces**: PascalCase with `I` prefix when needed

## Environment Variables

### Client-side

```typescript
// Use NEXT_PUBLIC_ prefix for client-side access
const convex = new ConvexReactClient(process.env.NEXT_PUBLIC_CONVEX_URL!);
```

### Server-side

```typescript
// Direct access in API routes and server components
const client = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
```

## Performance Considerations

### Code Splitting

- **Dynamic imports**: Use for heavy components
- **Route-based splitting**: Automatic with App Router
- **Component lazy loading**: When appropriate

```typescript
import dynamic from 'next/dynamic';

const HeavyComponent = dynamic(() => import('./HeavyComponent'), {
  loading: () => <div>Loading...</div>,
});
```

### Image Optimization

```typescript
import Image from 'next/image';

<Image
  src="/casino-logo.png"
  alt="Casino Logo"
  width={200}
  height={100}
  priority={isAboveFold}
/>
```

## Testing Patterns

### Component Testing

```typescript
import { render, screen } from '@testing-library/react';
import { Button } from '@/components/ui/button';

test('renders button with correct text', () => {
  render(<Button>Click me</Button>);
  expect(screen.getByText('Click me')).toBeInTheDocument();
});
```

### API Testing

```typescript
import { POST } from '@/app/api/discover-casinos/route';

test('POST /api/discover-casinos returns success', async () => {
  const response = await POST();
  const data = await response.json();

  expect(response.status).toBe(200);
  expect(data.ok).toBe(true);
});
```

## Implementation Checklist

### When Creating New Features

- [ ] Create feature folder in `src/features/{feature-name}/`
- [ ] Add service classes for business logic
- [ ] Define Zod schemas for data validation
- [ ] Create TypeScript types
- [ ] Add API routes if needed
- [ ] Implement UI components
- [ ] Add error handling
- [ ] Write tests

### When Adding Components

- [ ] Place in appropriate directory (`ui/` or `{feature}/`)
- [ ] Use shadcn/ui patterns for base components
- [ ] Add proper TypeScript types
- [ ] Include accessibility attributes
- [ ] Use `cn()` utility for conditional styling
- [ ] Export with proper naming conventions
- [ ] **Add skeleton loading states for data-fetching components**
- [ ] **Use shadcn/ui Skeleton component for loading placeholders**
- [ ] **Match skeleton dimensions to final content layout**

### When Creating API Routes

- [ ] Use proper HTTP method exports
- [ ] Include error handling with try/catch
- [ ] Return consistent response format
- [ ] Add proper TypeScript types
- [ ] Validate input data
- [ ] Handle edge cases

This architecture ensures maintainable, scalable, and type-safe Next.js applications with clear separation of concerns and modern React patterns.
